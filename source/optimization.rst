Оптимизация
===========

Попробуйте ``dmd -release -inline -O``.

Dmd компилятор генерирует отличный код,
но в сравнении не самый популярный движок компиляции.
Чтобы увеличить производительность на 10-20% (или для микротестов)
используйте LDC или GDC.
Все три компилятора используют одинаковый фронтенд,
но LDC использует LLVM и GDC использует GCC в качестве бекэнда.


Тем не менее, dmd официальный компилятор и поведение
LDC c GDC немного отличаются от него.
К тому же dmd довольно быстр, что ускоряет разработку в целом.

Профилирование
--------------

Так как компилятор не может все оптимизировать, программист часто должен
вручную настраивать свой код.
Трудно предсказать узкие места в коде, а значит необходимо
пользоваться профилированием.
Опция ``-profile`` в dmd для этого.
После запуска программы,  в ``trace.log`` можно найти следующую сходную информацию.

.. code-block:: txt

   ------------------
   [... bla bla many lines of raw information ...]

   === Timer Is 3579545 Ticks/Sec, Times are in Microsecs ===

      Num    Tree   Func   Per
      Calls  Time   Time   Call

      2     77773  77742  38871 std.stdio.writeln(immutable(char)[])
      1    231962  75516  75516 std.concurrency.MessageBox.get...
      1     71344  70125  70125 std.concurrency._send(...)
      1     50818  50818  50818 std.stdio.File.LockingTextWriter...

   [... bla bla more data ...]

Эта таблица показывает самые прожорливые по времени функции.
Судя по всему,  ``writeln`` доминирует с суммарным временем 77742 мс за 2 вызова.
Средний вызов занимает 38871 мс.
``MessageBox.get`` занимает немного меньше времени,
однако в дереве времени занимает аж 231962 мс,
что является суммарным временем с момента вызова и возращения контекста функцией.

Анализ производительности
-------------------------

Бенчмаркинг естественно необходим для оптимизации узких мест в системе.
D предоставляет ``std.datetime.benchmark`` и ``comparingBenchmark``
для простого сравнения производительности.

.. code-block:: d

   int a;
   void f0() {}
   void f1() {auto b = a;}
   void f2() {auto b = to!(string)(a);}
   auto r = benchmark!(f0, f1, f2)(10_000);
   writefln("Milliseconds to call fun[0] n times: %s", r[0].msecs);
